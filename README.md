# System Programming Lab 11 Multiprocessing
# System Programming Lab 12 Multithreading
/*
 * Filename: System Programming Lab 11 & 12 Multiprocessing/Multithreading
 * Description: README (Lab report) for Multiprocessing & Multithreading
 * Author: Stephen Henry
 * Date:11/25/2025 & 11/28/2025
 * how to compile: gcc -o mandel mandel.c movie.c -o movie
 */


With this lab we used up to 50 processes to retrieve 50 images of a Mandelbrat. By running various amounts of processes
affects the time it takes to process it all and but not the value of the image. Reading through the man pages for ffmpeg 
it is the -framerate ## that alters the speed of the movie, so runtime is the focus with the processes. 

Readings were taken of time it takes to run with 1,2,5,10,20 processes. The Real, User, and Sys times were produced.
Real time gets higher the less processes used. User time became faster the less processes used (except) with the
2 processes running. I received a faster time than when 5 and 1 process was running. Sys time gets faster with the 
lower processes. 2 processes is still the anomly in my readings though.

Readings filed in excel chart and AI generated line chart.
13 processes are running in the selected movie that was demo'd and also included in submission.

UPDATE: Lab 12 I had to add a struct for the threads and a function in the mandel.c source file. 
Integrated thread calls into the movie source file movie.c.
When I ran the threads, I kept equal threads and processes (1,2,5,10,20). 
In my findings I noticed that the more threads I added, the REAL runtime is faster, but the USER runtime slows down.
The SYS runtime fluctuates up and down, but not by much in my opinion. I had another chart generated by AI to compare
the processes and threads of the same numbers over the allotted amount of time.
For the sake of curiosity, I ran the program with 25 processes and 20 threads which gave me these results:
REAL: 24.915s
USER: 5m 59.106s
SYS:  0.599s
I ran the results onto mandel5.mpg
